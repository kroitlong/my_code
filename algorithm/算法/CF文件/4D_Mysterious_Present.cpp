#include<cstdio>
int n, w[5001], h[5001], to[5001], d[5001];
int dp(int v)
{
    //如果已经计算过结点v对应的长度，则直接返回其长度，否则按如下规则计算以结点v起始的
    //最长递增子序列的长度
    if (d[v])return d[v];
    //首先将其初始化为1，表示此时序列只有自身，然后遍历所有结点（包括自身），找到比当前
    //结点大的值，然后计算以该结点起始的最长递增子序列的长度，如果将该节点添加到当前结点
    //后面能够增加d[v]，则更新d[v]，并设置to[v]=i，表示当前以v为起点的最长子序列的下一
    //个结点时i号结点，当遍历完所有结点后，就能得到每个以当前结点（设为i号结点）为起点的最
    //长递增子序列的长度，并存储在d[i]里。并且每个序列起始节点的下一个结点位置被存储在to中
    d[v] = 1;
    for (int i = 0; i <= n; i++)if (w[i] > w[v] && h[i] > h[v])if (dp(i) + 1 > d[v])to[v] = i, d[v] = d[i] + 1;
    return d[v];
}
int main()
{
    int i;
    scanf("%d", &n);
    for (i = 0; i <= n; i++)to[i] = -1, scanf("%d%d", w + i, h + i);
    dp(0);//d(0)表示最小的宽度和高度，即输入的宽度和高度为起始的最长递增子序列的长度，通过该值进行dp
    printf("%d\n", --d[0]);//此时链的长度要除去第一个值
    for (i = to[0]; i != -1; i = to[i])printf("%d ", i);//按照结点关系遍历to数组就能得到整条链每个结点的位置了
}